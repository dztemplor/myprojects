1.
this test shows a inter-process race condtion.

for a netlink socket fd, when we fork(), it's duplicated, and close() in one process doesn't destroy it in kernel, so SOCK_CLOEXEC is useful to close it after exec.

bind() will fail in second bind1() if the close() is not done in both processes.

if we dont' use SOCK_CLOEXEC, we can use kernel's autobind(check af_netlink.c). if we set nl_pid to 0, the first port_id is process id, the following are generated by 
kernel. thus we can' still bind.
